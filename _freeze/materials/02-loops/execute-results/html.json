{
  "hash": "2c076dbe2d3509582e81b566d1e7ca45",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Loops\"\noutput: html_document\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport random\nimport statistics\nimport matplotlib.pyplot as plt\nfrom plotnine import *\n```\n:::\n\n\n\n:::\n:::\n\nIn the previous chapter, we learned how to sample random datasets from known distributions.\n\nHere, we'll combine that with a fundamental programming technique: loops.\n\n## Soft-coding parameters\n\nBefore we get onto loops, we have one quick detour to take.\n\nIn the last chapter, we \"hard-coded\" our parameters by putting them directly inside the `rnorm` or `np.random.normal` functions.\n\nHowever, from here on, we will start \"soft-coding\" parameters or other values that we might want to change.\n\nThis is considered good programming practice. It's also sometimes called \"dynamic coding\".\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100\nmean_n <- 0\nsd_n <- 1\n\nrnorm(n = n, mean = mean_n, sd = sd_n) %>%\n  hist()\n```\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/softcode rnorm-1.png){width=672}\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nn = 100\nmean = 0\nsd = 1\n\nplt.clf()\nplt.hist(np.random.normal(loc = mean, scale = sd, size = n))\nplt.show()\n```\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/softcode np.random.norm-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\nThis might look like we're writing out more code, but it will be helpful in more complex simulations where we use the same parameter more than once.\n\nWe're also separating out the bits of the code that might need to be edited, which are all at the top where we can more easily see them, versus the bits we can leave untouched. \n\n## Loops\n\nIn programming, a loop is a chunk of code that is run repeatedly, until a certain condition is satisfied.\n\nThere are two broad types of loop: the for loop and the while loop. For the purposes of this course, we'll only really worry about the for loop. For loops run for a pre-specified number of iterations before stopping.\n\n### For loop syntax\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R, the syntax for a for loop looks like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  \n  print(i)\n\n  }\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\nHere, `i` is our loop variable. It will take on the values in `1:5`, one at a time.\n\nFor each value of our loop variable, the code inside the loop body - defined by `{}` curly brackets in R - will run.\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 6):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\n3\n4\n5\n```\n\n\n:::\n:::\n\n\n\n\nHere, `i` is our loop variable. It will take on the values in `1:5`, one at a time.\n\n(Note that `range(1, 6)` does **not** include `6`, the endpoint.)\n\nFor each value of our loop variable, the code inside the loop body - defined by indentation in Python - will run.\n:::\n\nIn this case, all we are asking our loop to do is print `i`. It'll do this 5 times, increasing the value of `i` each time for each new iteration of the loop.\n\nBut, we can ask for more complex things than this on each iteration, and we don't always have to interact with `i`. \n\n### Visualising means with for loops {#sec-exm_mean-for-loop}\n\nYou might've guessed based on context clues, but we can use for loops to perform repeated simulations using the same starting parameters (in fact, we'll do that a lot in this course).\n\nIn this loop, we sample 3 unique datasets, each made up of 20 random data points, from a normal distribution with mean 4 and standard deviation 0.5.\n\nThen, we produce a histogram for each dataset, overlaying the mean value each time.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  \n  n <- 20\n  mean_n <- 4\n  sd_n <- 0.5\n  \n  data <- rnorm(n, mean_n, sd_n) \n\n  hist(data, xlim = c(1, 7))\n  abline(v = mean(data), col = \"red\", lwd = 3)\n\n  }\n```\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple for loop-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple for loop-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple for loop-3.png){width=672}\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nplt.close()\n\nfor i in range(1, 4):\n  n = 20\n  mean = 4\n  sd = 0.5\n  data = np.random.normal(mean, sd, n)\n  plt.figure()\n  plt.hist(data)\n  plt.axvline(x = statistics.mean(data), color = 'r')\n  plt.show()\n```\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple loop with np.r.n-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple loop with np.r.n-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](02-loops_files/figure-html/less simple loop with np.r.n-3.png){width=672}\n:::\n:::\n\n\n\n:::\n\nWe can see that the means in each case are mostly hovering around 4, which is reassuring, since we know that's the true population mean.\n\n## Exercises\n\n### Even numbers {#sec-exr_evennums}\n\n::: {.callout-exercise}\n\n\n\n\n{{< level 1 >}}\n\n\n\n\n\n\nWrite a for loop that prints out all of the even numbers between 1 and 100 (inclusive).\n\n::: {.callout-tip collapse=\"true\"}\n#### Worked answer\n\nThere's actually a couple of different ways you could do this:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n#### Method 1\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:50) {\n  print(i*2)\n}\n```\n:::\n\n\n\n\n#### Method 2\n\nThis method uses another programming essential, the if-statement.\n\nWe won't really use if-statements much in this course, but if you can get your head around the for loop syntax, you can definitely manage an if-statement, and it doesn't hurt to know they exist!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100) {\n  if (i%%2 == 0) {\n    print(i)\n  }\n}\n```\n:::\n\n\n\n\n## Python\n\n#### Method 1\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1,51):\n  print(i*2)\n```\n:::\n\n\n\n\nThe only thing to watch here is that Python uses zero-indexing, i.e., starts counting from 0 instead of 1. \n\nThis means that writing `range(50)` here doesn't actually get you the right numbers!\n\n#### Method 2\n\nThis method uses another programming essential, the if-statement.\n\nWe won't really use if-statements much in this course, but if you can get your head around the for loop syntax, you can definitely manage an if-statement, and it doesn't hurt to know they exist!\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1,101):\n  if i % 2 == 0:\n    print(i)\n```\n:::\n\n\n\n\nAgain, watch for zero-indexing!\n:::\n:::\n:::\n\n### Fizzbuzz {#sec-exr_fizzbuzz}\n\nLet's do something a little different, to really show the power of loops.\n\nFor some context, for those of you who've never played: [Fizzbuzz](https://en.wikipedia.org/wiki/Fizz_buzz) is a silly parlour game that involves taking it in turns to count, adding 1 each time. \n\nThe trick is that all multiples of 3 must be replaced with the word \"fizz\", and all multiples of 5 with the word \"buzz\" (and multiples of both with \"fizzbuzz\").\n\n::: {.callout-exercise}\n\n\n\n\n{{< level 3 >}}\n\n\n\n\n\n\nIn this exercise, write a for loop that will play the Fizzbuzz game all by itself, up to the number 100.\n\nNote: you will need to make if-else statements within your loop for this to work!\n\n::: {.callout-tip collapse=\"true\"}\n#### Answer\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100){\n  \n  if (i%%3 == 0 & i%%5 == 0) {\n    print(\"fizzbuzz\")\n  } else if (i%%5 > 0 & i%%3 == 0) {\n    print(\"fizz\")\n  } else if (i%%5 == 0 & i%%3 > 0) {\n    print(\"buzz\")\n  } else {\n    print(i)\n  }\n  \n}\n```\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1,101):\n  if i%3 == 0 and i%5 == 0: print(\"fizzbuzz\")\n  elif i%3 == 0 and i%5 > 0: print(\"fizz\")\n  elif i%5 == 0 and i%3 > 0: print(\"buzz\")\n  else: print(i)\n```\n:::\n\n\n\n:::\n:::\n\n:::\n\n## Summary\n\nThis chapter covers some key coding practices that will be important later, including \"soft-coding\" of variables and for loops.\n\n::: {.callout-tip}\n#### Key Points\n\n-   Soft-coding, or dynamic coding, means assigning key parameters at the top of a script rather than within functions, so that they can more easily be changed later\n-   For loops in programming are chunks of code that are executed for a pre-specified number of iterations\n:::\n\n",
    "supporting": [
      "02-loops_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}